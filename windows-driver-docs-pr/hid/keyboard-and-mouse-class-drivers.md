---
title: キーボードとマウスのクラス ドライバー
description: 非 HID のキーボードおよびマウスは複数のレガシバス経由で接続できますが、同じクラスドライバーを使用します。
ms.assetid: 0771D802-4F1D-4612-8376-ED3113DCC652
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: df9d233525f9c32998c76e1771e703dc6f108ae7
ms.sourcegitcommit: ca5045a739eefd6ed14b9dbd9249b335e090c4e9
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/06/2020
ms.locfileid: "85968219"
---
# <a name="keyboard-and-mouse-class-drivers"></a>キーボードとマウスのクラス ドライバー

非 HID のキーボードおよびマウスは複数のレガシバス経由で接続できますが、同じクラスドライバーを使用します。 ここでは、クラスドライバー自体について詳しく説明します。 次のセクションでは、コントローラーの詳細について説明します。

このトピックでは、Microsoft Windows 2000 以降でのキーボードおよびマウスデバイスの一般的な物理構成について説明します。

次の図は、1つのキーボードと1つのマウスを使用する2つの一般的な構成を示しています。

![1つのキーボードと1つのマウスを使用する2つの構成を示す図](images/kemocfg1.png)

左側の図は、独立したコントローラーを介してシステムバスに接続されたキーボードとマウスを示しています。 標準的な構成は、i8042 コントローラーを介して動作する PS/2 スタイルのキーボードと、シリアルポートコントローラーを介して操作されるシリアルスタイルのマウスで構成されます。

次の追加情報は、キーボードおよびマウスの製造元にとって重要です。

- セキュリティ上の理由から、オペレーティングシステムスタックによって、キーボードが排他モードで開かれる
- Windows では、複数のキーボードおよびマウスデバイスの同時接続がサポートされています。
- Windows は、各デバイスに対するクライアントによる独立したアクセスをサポートしていません。

## <a name="class-driver-features"></a>クラスドライバーの機能

このトピックでは、次の Microsoft Windows 2000 および system クラスのドライバーの機能について説明します。

- **Kbdclass**、GUID クラスのデバイスのクラスドライバー \_ の \_ デバイスクラス

- MOUSE**クラス**、GUID クラスのデバイスのクラスドライバー \_ 、 \_ MOUSE device クラス

Kbdclass は Kbdclass サービスを実装し、その実行可能イメージは kbdclass.sys ます。

を実行すると、このクラスは、このサービスを実装し、その実行可能イメージを mouclass.sys します。

Kbdclass と、各機能の各機能:

- デバイスクラスの汎用的でハードウェアに依存しない操作。

- プラグアンドプレイ、電源管理、および Windows Management Instrumentation (WMI)。

- レガシデバイスの操作。

- 複数のデバイスの同時操作。

- [クラスサービスコールバックルーチン](https://docs.microsoft.com/windows-hardware/drivers/ddi/kbdmou/nc-kbdmou-pservice_callback_routine)の接続。関数ドライバーは、デバイスの入力データバッファーからクラスドライバーのデータバッファーにデータを転送するために使用します。

## <a name="configuration-of-device-objects"></a>デバイスオブジェクトの構成

次の図は、プラグアンドプレイ PS/2 スタイルのキーボードおよびマウスデバイスのデバイスオブジェクトの構成を示しています。 各クラスドライバーは、オプションの上位レベルのデバイスフィルターを使用して、関数デバイスオブジェクト (*FDO*) にアタッチされている上位レベルのクラス*フィルターデバイスオブジェクト*(filter do) を作成します。 上位レベルのデバイスフィルタードライバーは、上位レベルのデバイスフィルターを作成します。 I8042prt は、関数を作成し、ルートバスドライバーによって作成された物理デバイスオブジェクト (*PDO*) にアタッチします。

![プラグアンドプレイ ps/2 スタイルのキーボードおよびマウスデバイス用のデバイスオブジェクトの構成を示す図](images/km-ovr2.png)

### <a name="ps2-keyboard"></a>PS/2 キーボード

キーボードドライバースタックは、次の要素で構成されています。

- **Kbdclass**、上位レベルのキーボードクラスフィルタードライバー
- 1つまたは複数のオプションのトップレベルキーボードフィルタードライバー
- **I8042prt**, 関数ドライバー

### <a name="ps2-mouse"></a>PS/2 マウス

マウスドライバースタックは、次の要素で構成されています。

- 右上**クラス**、上位レベルのマウスクラスフィルタードライバー
- 1つまたは複数のオプションの上位レベルのマウスフィルタードライバー
- **I8042prt**, 関数ドライバー

**Kbdclass と****クラス**は、2つの異なるモードで複数のデバイスをサポートできます。 1対*1 モード*では、各デバイスに独立したデバイススタックがあります。 クラスドライバーは、独立したクラスを作成し、各デバイススタックにアタッチします。 各デバイススタックには、独自の制御状態と入力バッファーがあります。 Microsoft Win32 サブシステムは、一意のファイルオブジェクトを介して各デバイスからの入力にアクセスします。

*Grandmaster モード*では、クラスドライバーは、次の方法ですべてのデバイスを操作します。

- クラスドライバーは、すべてのデバイスを表す*grandmaster クラス*と、各デバイスの*下位クラス*を作成します。

    クラスドライバーは、下位クラスを各デバイススタックにアタッチします。 下位クラスの下では、デバイススタックは一対一モードで作成されたものと同じです。

- Grandmaster クラスは、すべての下位 DOs の操作を制御します。

- Win32 サブシステムは、grandmaster クラスデバイスを表す file オブジェクトを介して、すべてのデバイス入力にアクセスします。

- すべてのデバイス入力は、grandmaster のデータキューでバッファリングされます。

- Grandmaster は、1つのグローバルデバイス状態を保持します。

Kbdclass およびの各クラスは、1対1モードで動作します。レジストリエントリ値**connect複数ポート**が0x00 に設定されている場合 (ここで、*クラスサービス*が Kbdclass または** \\ \\ CurrentControlSet \\ *** &lt; &gt; *** \\ **クラスである場合)。 それ以外の場合は、Kbdclass とは grandmaster モードで動作します。

## <a name="open-and-close-via-the-class-driver"></a>クラスドライバーを使用してを開き、閉じる

Microsoft Win32 サブシステムによって、すべてのキーボードおよびマウスデバイスが排他的に使用されます。 Win32 サブシステムでは、デバイスクラスごとに、入力が単一の入力デバイスからのものであるかのように、すべてのデバイスからの入力を扱います。 アプリケーションは、1つの特定のデバイスからの入力のみを受信するように要求することはできません。

Win32 サブシステムは、GUID \_ クラス \_ キーボードまたは guid \_ クラスの \_ マウスデバイスインターフェイスが有効になっていることをプラグアンドプレイマネージャーから通知を受け取った後、入力デバイスプラグアンドプレイ動的に開きます。 Win32 サブシステムは、開いているインターフェイスが無効になっているという通知を受信した後、プラグアンドプレイデバイスを閉じます。 Win32 サブシステムでは、レガシデバイスも名前で開かれます (たとえば、" \\ Device \\ KeyboardLegacyClass0")。 Win32 サブシステムがレガシデバイスを正常に開くと、デバイスが後で物理的に削除されたかどうかを判断できないことに注意してください。

Kbdclass とは、作成要求を受け取ると、プラグアンドプレイ次の操作を実行します。

- **プラグアンドプレイ操作**

    デバイスがプラグアンドプレイ開始状態になっている場合、クラスドライバーは IRP \_ MJ \_ CREATE 要求をドライバースタックに送信します。 それ以外の場合、クラスドライバーは要求をドライバースタックに送信せずに要求を完了します。 クラスドライバーは、デバイスに対する読み取りアクセス権を持つ信頼されたファイルを設定します。 Grandmaster デバイスがある場合、クラスドライバーは、下位クラスのデバイスに関連付けられているすべてのポートに create 要求を送信します。

- **レガシ操作**

    クラスドライバーは、デバイスを有効にするために、デバイスコントロールの内部要求をポートドライバーに送信します。

## <a name="connect-a-service-callback-to-a-device"></a>サービスコールバックをデバイスに接続する

クラスドライバーは、デバイスを開く前に、そのクラスのサービスをデバイスに接続する必要があります。 クラスドライバーは、クラスをデバイススタックにアタッチした後に、クラスサービスを接続します。 関数ドライバーは、クラスのサービスコールバックを使用して、デバイスからデバイスのクラスデータキューに入力データを転送します。 デバイスの関数ドライバーの ISR ディスパッチ完了ルーチンは、クラスサービスコールバックを呼び出します。 Kbdclass はクラスサービスコールバック[**KeyboardClassServiceCallback**](https://docs.microsoft.com/previous-versions/ff542324(v=vs.85))を提供します。また、クラスはクラスサービスコールバック[**MouseClassServiceCallback**](https://docs.microsoft.com/previous-versions/ff542394(v=vs.85))を提供します。

ベンダは、デバイスの上位レベルのフィルタードライバーをインストールすることによって、クラスサービスコールバックの動作を変更できます。 サンプルのキーボードフィルタードライバー [Kbfiltr](https://docs.microsoft.com/samples/microsoft/windows-driver-samples/keyboard-input-wdf-filter-driver-kbfiltr/)では、 [**kbfilter \_ ServiceCallback**](https://docs.microsoft.com/previous-versions/ff542297(v=vs.85)) callback[が定義さ](https://docs.microsoft.com/samples/microsoft/windows-driver-samples/mouse-input-wdf-filter-driver-moufiltr/)れています。また、サンプルのマウスフィルタードライバーの例では、 [** \_ ServiceCallback**](https://docs.microsoft.com/previous-versions/ff542380(v=vs.85)) callback が定義されています。 サンプルフィルターサービスのコールバックは、デバイスのポート入力バッファーからクラスデータキューに転送される入力データを変更するように構成できます。 たとえば、フィルターサービスのコールバックでは、データの削除、変換、または挿入を行うことができます。

クラスとフィルターサービスのコールバックは、次のように接続されます。

- クラスドライバーは、デバイススタック ([**ioctl \_ 内部 \_ キーボード \_ 接続**](https://docs.microsoft.com/windows-hardware/drivers/ddi/kbdmou/ni-kbdmou-ioctl_internal_keyboard_connect)または[**ioctl \_ 内部 \_ マウス \_ 接続**](https://docs.microsoft.com/windows-hardware/drivers/ddi/kbdmou/ni-kbdmou-ioctl_internal_mouse_connect)) を介して、内部デバイス接続要求を送信します。 クラス接続データは、CONNECT データ構造体によって指定されます。これには、 \_ クラスデバイスオブジェクトへのポインターとクラスサービスコールバックへのポインターが含まれます。

- フィルタードライバーは、connect 要求を受信すると、クラス接続データのコピーを保存し、要求の connect データをフィルター接続データに置き換えます。 フィルター接続データは、フィルターデバイスオブジェクトへのポインターとフィルタードライバーサービスコールバックへのポインターを指定します。 フィルタードライバーは、フィルター処理された connect 要求を関数ドライバーに送信します。

クラスとフィルターサービスのコールバックは、次の方法で呼び出されます。

- 関数ドライバーは、フィルター接続データを使用して、フィルターサービスコールバックに最初のコールバックを行います。

- フィルターサービスのコールバックでは、入力データをフィルター処理した後、クラスサービスコールバックにコールバックするために、保存したクラス接続データを使用します。

## <a name="query-and-set-a-keyboard-device"></a>キーボードデバイスのクエリと設定

I8042prt は、キーボードデバイスに関する情報を照会し、キーボードデバイスでパラメーターを設定するために、次の内部デバイス制御要求をサポートしています。

[**IOCTL \_ キーボード \_ クエリの \_ 属性**](https://docs.microsoft.com/windows/desktop/api/ntddkbd/ni-ntddkbd-ioctl_keyboard_query_attributes)

[**IOCTL \_ キーボード \_ クエリ \_ インジケーター \_ 変換**](https://docs.microsoft.com/windows/desktop/api/ntddkbd/ni-ntddkbd-ioctl_keyboard_query_indicator_translation)

[**IOCTL \_ キーボード \_ クエリ \_ インジケーター**](https://docs.microsoft.com/windows/desktop/api/ntddkbd/ni-ntddkbd-ioctl_keyboard_query_indicators)

[**IOCTL \_ キーボード \_ クエリ \_ 速度**](https://docs.microsoft.com/windows/desktop/api/ntddkbd/ni-ntddkbd-ioctl_keyboard_query_typematic)

[**IOCTL \_ キーボード \_ セット \_ インジケーター**](https://docs.microsoft.com/windows/desktop/api/ntddkbd/ni-ntddkbd-ioctl_keyboard_set_indicators)

[**IOCTL \_ キーボード \_ セット \_ 速度**](https://docs.microsoft.com/windows/desktop/api/ntddkbd/ni-ntddkbd-ioctl_keyboard_set_typematic)

すべてのキーボードデバイスコントロール要求の詳細については、「[ヒューマンインターフェイスデバイスリファレンス](https://docs.microsoft.com/windows/win32/api/_hid/)」を参照してください。

## <a name="scan-code-mapper-for-keyboards"></a>キーボードのコードマッパーをスキャンする

Microsoft Windows オペレーティングシステムでは、入力デバイスによって提供される PS/2 互換のスキャンコードが仮想キーに変換され、Windows メッセージの形式でシステムを通じて伝達されます。 デバイスが特定のキーに対して正しくないスキャンコードを生成すると、誤った仮想キーメッセージが送信されます。 これは、ファームウェアによって生成されるスキャンコードを分析するフィルタードライバーを記述し、システムによって認識されるスキャンコードを修正することによって修正できます。 ただし、これは面倒なプロセスであり、カーネルレベルのフィルタードライバーにエラーが存在すると、重大な問題が発生する可能性があります。

Windows 2000 および Windows XP には、スキャンコードのマッピングを可能にするメソッドを提供する新しいスキャンコードマッパーが付属しています。 Windows のスキャンコードのマッピングは、次のレジストリキーに格納されています。

``` syntax
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout
```

**メモ**   また、コントロールキーの下に**キーボードレイアウト**キー (複数形に注意してください) もありますが、そのキーは変更しないでください。

**キーボードレイアウト**キーでは、 **scancode マップ**値を追加する必要があります。 この値は、型 REG \_ BINARY (リトルエンディアン形式) で、次の表に示すデータ形式が指定されています。

|                         |                 |                              |
|-------------------------|-----------------|------------------------------|
| 開始オフセット (バイト単位) | サイズ (バイト単位) | データ                         |
| 0                       | 4               | ヘッダー: バージョン情報  |
| 4                       | 4               | Header: フラグ                |
| 8                       | 4               | ヘッダー: マッピングの数   |
| 12                      | 4               | 個々のマッピング           |
| ...                     | ...             | ...                          |
| 過去4バイト            | 4               | Null ターミネータ (0x00000000) |

1番目と2番目の DWORD ストアヘッダー情報は、現在のバージョンのスキャンコードマッパーのすべてゼロに設定する必要があります。 3番目の DWORD エントリには、その後に続くマッピングの総数 (null 終端マッピングを含む) が含まれます。 したがって、最小カウントは 1 (マッピングが指定されていない) になります。 個々のマッピングはヘッダーの後に続きます。 各マッピングは、長さが1つの DWORD で、2つの単語長フィールドに分割されます。 各 WORD フィールドには、マップするキーのスキャンコードが格納されます。

マップがレジストリに格納されたら、マッピングを有効にするためにシステムを再起動する必要があります。 Keypress でスキャンコードのマッピングが必要な場合は、スキャンコードが仮想キーに変換される直前に、ユーザーモードでステップが実行されることに注意してください。 この変換をユーザーモードで行うと、ターミナルサービスで実行しているときにマッピングが正しく機能しないなど、特定の制限が生じることがあります。

これらのマッピングを削除するには、Scancode Map レジストリ値を削除し、再起動します。

### <a name="example-1"></a>例 1

次に例を示します。 左の CTRL キーと CAPSLOCK キーを交換するには、レジストリエディター (可能であれば Regedt32.exe) を使用して、Scancode マップキーを次の値で変更します。

``` syntax
00000000 00000000 03000000 3A001D00 1D003A00 00000000
```

次の表は、これらのエントリが DWORD フィールドに分割され、スワップされたバイト数を示しています。

**値**: 解釈

**0x00000000**: ヘッダー: バージョン。 すべてゼロに設定します。

**0x00000000**: Header: フラグ。 すべてゼロに設定します。

**0x00000003**: マップ内の3つのエントリ (null エントリを含む)。

**0X001d003a**: 左 CTRL キー-- &gt; CAPS LOCK (0x1d-- &gt; 0x3a)。

**0X003a001d**: CAPS LOCK-- &gt; ← + CTRL キー (0x3a-- &gt; 0x1d)。

**0x00000000**: Null ターミネータ。


### <a name="example-2"></a>例 2

キーボードで一般に利用できないキーを追加したり、使用されていないキーを削除したりすることもできます。 次の例では、 **Scancode Map**に格納されている値を使用して、右 CTRL キーを削除し、右 ALT キーの機能をミュートキーとして機能するように変更しています。

``` syntax
00000000 00000000 03000000 00001DE0 20E038E0 00000000
```

次の表は、これらのエントリが DWORD フィールドに分割され、スワップされたバイト数を示しています。

**値**: 解釈

**0x00000000**: ヘッダー: バージョン。 すべてゼロに設定します。

**0x00000000**: Header: フラグ。 すべてゼロに設定します。

**0x00000003**: マップ内の3つのエントリ (null エントリを含む)。

**0Xe01d0000**: 右の CTRL キー (0xE01D-- &gt; 0x00) を削除します。

**0xE038E020**: Right ALT key-- &gt; ミュートキー (0xe038-- &gt; 0xe038)。

**0x00000000**: Null ターミネータ。


必要なデータが生成されたら、いくつかの方法でレジストリに挿入できます。

- レジストリエディターを使用して、システムレジストリに簡単に組み込むことができる .reg ファイルを生成できます。
- \[ \] 追加するレジストリ情報が含まれている AddReg セクションで .inf ファイルを作成することもできます。
- Regedt32.exe を使用して、手動で情報をレジストリに追加できます。

スキャンコードマッパーには、いくつかの利点と欠点があります。

次のような利点があります。

- マッパーは、ファームウェアエラーを修正するための簡単な修正プログラムとして使用できます。
- 頻繁に使用されるキーは、レジストリのマップを変更することでキーボードに追加できます。 頻繁に使用されないキー (右 CTRL キーなど) は、null にマップしたり、他のキーと交換したりすることができます。
- キーの場所は簡単に変更できます。 ユーザーは、頻繁に使用されるキーの場所を簡単にカスタマイズできます。

次の欠点が認識されます。

- マップがレジストリに格納されたら、システムを再起動してアクティブ化する必要があります。
- レジストリに格納されているマッピングはシステムレベルで動作し、すべてのユーザーに適用されます。 これらのマッピングは、現在のユーザーによって異なる方法で動作するように設定することはできません。
- 現在の実装では、マッピングがシステムに接続されているすべてのキーボードに常に適用されるように、マップの機能が制限されています。 現在、キーボードベースでマップを作成することはできません。

## <a name="query-a-mouse-device"></a>マウスデバイスのクエリ

I8042prt は、次の内部デバイスコントロール要求をサポートして、マウスデバイスに関する情報を照会します。

[**IOCTL \_ マウス \_ クエリ \_ 属性**](https://docs.microsoft.com/previous-versions/windows/hardware/drivers/ff542085(v=vs.85))

すべてのマウスデバイスコントロール要求の詳細については、「[ヒューマンインターフェイスデバイスリファレンス](https://docs.microsoft.com/windows/win32/api/_hid/)」を参照してください。

## <a name="registry-settings-associated-with-mouse-class-driver"></a>マウスクラスドライバーに関連付けられているレジストリ設定

マウスクラスドライバーに関連付けられているレジストリキーの一覧を次に示します。

\[キー: HKLM \\ SYSTEM \\ CurrentControlSet \\ Services の \\ \\ パラメーター\]

- **Maximumportsserviced** -Windows XP 以降では使用されません。 Windows NT4 の場合のみ。
- **ポインター devicebase-access** –マウスクラスのデバイスドライバーによって作成されるデバイスオブジェクトの基本名を指定します。
- **Connect複数ポート**–クラスデバイスオブジェクトごとに1つまたは複数のポートデバイスオブジェクトがあるかどうかを判断します。 このエントリは、主にデバイスドライバーによって使用されます。
- **Mousedataを**指定する-マウスドライバーによってバッファリングされるマウスイベントの数を指定します。 また、非ページメモリプール内のマウスドライバーの内部バッファーのサイズを計算するときにも使用されます。

## <a name="absolute-pointing-devices"></a>絶対ポイントデバイス

[**GUID \_ クラス \_ MOUSE**](https://docs.microsoft.com/windows-hardware/drivers/install/guid-class-mouse)型のデバイスの場合、デバイスの関数ドライバーは次のとおりです。

- デバイス固有の入力を処理します。

- [**MouseClassServiceCallback**](https://docs.microsoft.com/previous-versions/ff542394(v=vs.85))で必要な[**マウス \_ 入力 \_ データ**](https://docs.microsoft.com/windows/win32/api/ntddmou/ns-ntddmou-mouse_input_data)構造を作成します。

- \_ \_ ISR ディスパッチ完了ルーチンで**MouseClassServiceCallback**を呼び出すことによって、マウス入力データ構造をマウス入力データのデータキューに転送します。

絶対ポインティングデバイスの場合、デバイスの関数ドライバーは、 **Flags**次のように、マウス入力データ構造体の**lastx**、 **lastx**、および Flags のメンバーを設定する必要があり \_ \_ ます。

- デバイスの入力値をデバイスの最大機能で割るだけでなく、ドライバーはデバイスの入力値を0xFFFF でスケーリングします。

    ```cpp
    LastX = ((device input x value) * 0xFFFF ) / (Maximum x capability of the device)
    LastY = ((device input y value) * 0xFFFF ) / (Maximum y capability of the device)
    ```

- ドライバーは、マウス \_ 移動の \_ 絶対フラグを**フラグ**に設定します。

- 入力を Windows マネージャーによって仮想デスクトップ全体にマップする必要がある場合、ドライバーは、マウスの \_ 仮想 \_ デスクトップフラグを**フラグ**に設定します。 マウス \_ 仮想デスクトップの \_ フラグが設定されていない場合、ウィンドウマネージャーは入力をプライマリモニターのみにマップします。

次の例では、デバイスの種類によって、これらの特別な要件が絶対ポインティングデバイスにどのように実装されるかを指定します。

- HID デバイス:

    Microsoft の HID マウスデバイス用の Windows 関数ドライバーであるマウスを使用すると、これらの特別な要件が自動的に実装されます。

- PS/2 スタイルのデバイス:

    上位レベルのフィルタードライバーが必要です。 フィルタードライバーは、IsrHook コールバックとクラスサービスコールバックを提供します。 I8042prt は、未加工のデバイス入力を処理する IsrHook を呼び出し、フィルタークラスのサービスコールバックを呼び出して入力をフィルター処理します。 フィルタークラスのサービスコールバックは、 **MouseClassServiceCallback**を呼び出します。 IsrHook コールバックとクラスサービスコールバックの組み合わせにより、デバイス固有の入力が処理され、必要なマウス入力データ構造が作成され、 \_ \_ デバイス入力データが拡張され、マウス移動絶対フラグが設定され \_ \_ ます。

- Serenum.sys によって列挙されるプラグアンドプレイ COM ポートデバイス:

    プラグアンドプレイ関数ドライバーが必要です。 関数ドライバーは、必要なマウス \_ 入力データ構造を作成し、 \_ デバイス入力データをスケーリングし、 \_ \_ **MOUSECLASSSERVICECALLBACK**を呼び出す前にマウス移動絶対フラグを設定します。

- 非プラグアンドプレイ COM ポートデバイス:

    デバイス固有の関数ドライバーが必要です。 関数ドライバーは、必要なマウス \_ 入力データ構造を作成し、 \_ デバイス入力データをスケーリングし、 \_ \_ **MOUSECLASSSERVICECALLBACK**を呼び出す前にマウス移動絶対フラグを設定します。

- サポートされていないバス上のデバイス:

    デバイス固有の関数ドライバーが必要です。 関数ドライバーは、必要なマウス \_ 入力データ構造を作成し、 \_ デバイス入力データをスケーリングし、 \_ \_ **MOUSECLASSSERVICECALLBACK**を呼び出す前にマウス移動絶対フラグを設定します。

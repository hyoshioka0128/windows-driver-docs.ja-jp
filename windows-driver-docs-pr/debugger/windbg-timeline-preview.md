---
title: WinDbg プレビュー-タイムライン
description: このセクションでは、WinDbg プレビューでタイムトラベルタイムライン機能を操作する方法について説明します。
ms.date: 12/06/2019
ms.localizationpriority: medium
ms.openlocfilehash: 0903b47dc34bae20da988eb27b37ea66bc73b6e0
ms.sourcegitcommit: d30691c8276f7dddd3f8333e84744ddeea1e1020
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/19/2019
ms.locfileid: "75252055"
---
# <a name="windbg-preview---timeline"></a>WinDbg プレビュー-タイムライン

タイムトラベルデバッグ (TTD) を使用すると、プログラムの実行の記録であるトレースを記録できます。 タイムラインは、実行中に発生するイベントを視覚的に表現したものです。 これらのイベントの場所は、ブレークポイント、メモリ読み取り/書き込み、関数呼び出しと戻り値、および例外です。

![デバッガーのタイムライン](images/windbgx-timeline.png)

[タイムライン] ウィンドウを使用すると、重要なイベントをすばやく表示したり、相対位置を理解したり、TTD トレースファイル内の場所を簡単に移動したりできます。 複数のタイムラインを使用して、タイムトラベルトレースのイベントを視覚的に調査し、イベントの相関関係を検出します。

TTD トレースファイルを開き、データモデルのクエリを手動で作成しなくても、タイムラインウィンドウが表示されます。 同時に、すべてのタイムトラベルオブジェクトを使用して、より複雑なデータクエリを実行できるようになります。

タイムトラベルトレースファイルの作成と操作の詳細については、「[タイムトラベルデバッグ-概要](time-travel-debugging-overview.md)」を参照してください。

## <a name="types-of-timelines"></a>タイムラインの種類

タイムラインウィンドウには、次のイベントが表示されます。

- 例外 (特定の例外コードに対してさらにフィルター処理できます)
- ブレークポイント (ブレークポイントのタイムラインは、ブレークポイントの追加時にも自動的に追加されます)
- 関数呼び出し (module! 関数の形式で検索)
- メモリアクセス (2 つのメモリアドレス間の読み取り/書き込み/実行)

各イベントにマウスポインターを合わせると、ツールヒントで詳細情報が表示されます。 イベントをクリックすると、イベントのクエリが実行され、詳細情報が表示されます。 イベントをダブルクリックすると、TTD トレースファイル内のその場所に移動します。

### <a name="exceptions"></a>例外

トレースファイルを読み込むと、タイムラインがアクティブになると、記録内の例外が自動的に表示されます。

例外の種類や例外コードなどのブレークポイント情報にマウスポインターを合わせると、が表示されます。

![例外を示すデバッガーのタイムライン](images/windbgx-timeline-exceptions.png)

オプションの例外コードフィールドを使用して、特定の例外コードに対してさらにフィルター処理を行うことができます。

![[タイムラインデバッガーの例外] ダイアログボックス。タイムラインの種類が例外に設定され、例外コードが0xC0000004 に設定されていることを示します。](images/windbgx-timeline-exceptions-dialog.png)

また、特定の種類の例外に対して新しいタイムラインを追加することもできます。

### <a name="breakpoints"></a>ブレークポイント

ブレークポイントが追加されると、ブレークポイントのタイムラインがタイムラインに自動的に追加されます。 これは、たとえば、[ [Bp Set ブレークポイント] コマンド](bp--bu--bm--set-breakpoint-.md)を使用して行うことができます。 ブレークポイントにマウスポインターを合わせると、そのブレークポイントに関連付けられているアドレスと命令ポインターが表示されます。

![ブレークポイントを示すデバッガーのタイムライン](images/windbgx-timeline-breakpoints.png)

ブレークポイントがクリアされると、関連付けられているブレークポイントタイムラインが自動的に削除されます。

### <a name="function-calls"></a>関数呼び出し

タイムライン上の関数呼び出しの位置を表示できます。 これを行うには、`TimelineTestCode!multiplyTwo`などの `module!function`の形式で検索を行います。 `TimelineTestCode!m*`などのワイルドカードを指定することもできます。

![デバッガーでタイムラインを追加し、に入力された関数呼び出し名を表示する](images/windbgx-timeline-function-calls-dialog.png)

関数をポイントすると、関数名、入力パラメーター、値、および戻り値が表示されます。 この例は、表示されるパラメーターであるため、*バッファー*と*サイズ*を示しています。GetCppConGreeting。

![関数呼び出しを示すデバッガーのタイムライン](images/windbgx-timeline-function-calls.png)

### <a name="memory-access"></a>メモリ アクセス

メモリアクセスタイムラインを使用して、メモリの特定の範囲が読み取られたとき、またはコードの実行が行われた日時を表示します。 開始アドレスと終了アドレスは、2つのメモリアドレスの範囲を定義するために使用されます。

![[書き込み] ボタンがオンになっているタイムラインメモリアクセスダイアログを追加する](images/windbgx-timeline-memory-access-dialog.png)

メモリアクセス項目にマウスポインターを合わせると、値と命令ポインターが表示されます。

![メモリアクセスを示すデバッガーのタイムライン](images/windbgx-timeline-memory-access.png)

## <a name="work-with-timelines"></a>タイムラインを操作する

垂直の灰色の線は、タイムラインの上にカーソルを置いたときに続きます。 青い縦線は、トレース内の現在の位置を示します。

虫眼鏡アイコンをクリックして、タイムラインを拡大または縮小します。

上部のタイムラインコントロール領域で、四角形を使用してタイムラインのビューをパンします。 四角形の外側の区切り記号をドラッグして、現在のタイムラインビューのサイズを変更します。

![アクティブなビューポートの選択に使用される上部領域を表示しているデバッガーのタイムライン](images/windbgx-timeline-manipulation.png)

### <a name="mouse-movements"></a>マウスの動き

Ctrl + Scroll ホイールを使用して拡大/縮小します。

Shift + Scroll ホイールを使用して、横から横にパンします。

## <a name="timeline-debugging-techniques"></a>タイムラインデバッグ手法

タイムラインのデバッグ手法を示すために、ここでは[タイムトラベルデバッグのチュートリアル](time-travel-debugging-walkthrough.md)を再利用します。 このデモでは、最初の2つの手順を完了したことを前提としています。最初の2つの手順を使用して、サンプルコードをビルドし、TTD 記録を作成しました。

[セクション 1: サンプルコードをビルドする](https://docs.microsoft.com/windows-hardware/drivers/debugger/time-travel-debugging-walkthrough#build)

[セクション 2: "DisplayGreeting" サンプルのトレースを記録する](https://docs.microsoft.com/windows-hardware/drivers/debugger/time-travel-debugging-walkthrough#record)

このシナリオでは、最初の手順として、タイムトラベルトレースで例外を見つけます。 これを行うには、タイムライン上の唯一の例外をダブルクリックします。

[コマンド] ウィンドウを見ると、例外をクリックしたときに次のコマンドが発行されたことがわかります。

```dbgcmd
(2dcc.6600): Break instruction exception - code 80000003 (first/second chance not available)
Time Travel Position: CC:0
@$curprocess.TTD.Events.Where(t => t.Type == "Exception")[0x0].Position.SeekTo()
```

[**表示** >> **レジスタ**] を選択すると、タイムラインのこの時点でレジスタが表示され、調査が開始されます。

![例外とレジスタを示すデバッガーのタイムライン](images/windbgx-timeline-demo-lab-exception-registers.png)

コマンドの出力では、スタック (esp) と基本ポインター (ebp) が2つの非常に異なるアドレスを指していることに注意してください。 これは、スタックが破損していることを示している可能性があります。関数が返され、スタックが破損している可能性があります。 これを検証するには、CPU 状態が破損する前にに戻り、スタックの破損が発生したことを確認できるかどうかを確認する必要があります。

このようにして、ローカル変数とスタックの値を確認します。

ローカル値を**表示するに**は、[ローカル >> **表示**] を選択します。

コード実行スタックを表示するには、[ >> **スタック**の**表示**] を選択します。

トレースで障害が発生した時点では、エラー処理コードの実際の原因の後にいくつかの手順を終了するのが一般的です。 タイムトラベルを使用すると、実際の根本原因を特定するために、一度に命令を戻すことができます。

[**ホーム**] リボンで、[**ステップイン戻る**] コマンドを使用して、3つの手順を実行します。 このようにして、引き続きスタックの [ローカル] と [登録] を確認します。

コマンドウィンドウには、時間の移動位置とレジスタが表示されます。手順に従って3つの手順を実行します。

```dbgcmd
0:000> t-
Time Travel Position: CB:41
eax=00000000 ebx=00564000 ecx=c0d21d62 edx=7a1e4a6c esi=00061299 edi=00061299
eip=00540020 esp=003cf7d0 ebp=00520055 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
00540020 ??              ???
0:000> t-
Time Travel Position: CB:40
eax=00000000 ebx=00564000 ecx=c0d21d62 edx=7a1e4a6c esi=00061299 edi=00061299
eip=00061767 esp=003cf7cc ebp=00520055 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
DisplayGreeting!main+0x57:
00061767 c3              ret
0:000> t-
Time Travel Position: CB:3A
eax=0000004c ebx=00564000 ecx=c0d21d62 edx=7a1e4a6c esi=00061299 edi=00061299
eip=0006175f esp=003cf718 ebp=003cf7c8 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
DisplayGreeting!main+0x4f:
0006175f 33c0            xor     eax,eax
```

トレースのこの時点で、スタックと基本ポインターにはより意味のある値が含まれているため、破損が発生したコードのポイントに近づいているように見えます。

```dbgcmd
esp=003cf718 ebp=003cf7c8
```

また、[ローカル] ウィンドウには対象アプリからの値が含まれており、ソースコードウィンドウはトレースのこの時点でソースコードで実行する準備ができているコード行を強調表示します。

さらに詳しく調査するために、[メモリ] ウィンドウを開いて、スタックポインター (esp) メモリアドレスの近くの内容を表示することができます。 この例では、値は003cf7c8 です。 [**メモリ** >> **テキスト** >> **ascii** ] を選択して、そのアドレスに格納されている ascii テキストを表示します。

![レジスタスタックとメモリウィンドウを示すデバッガー](images/windbgx-timeline-demo-lab-registers-stack-memory.png)

## <a name="memory-access-timeline"></a>メモリアクセスタイムライン

対象のメモリ位置が特定されたら、その値を使用してメモリアクセスタイムラインを追加します。 [ **+ タイムラインの追加**] をクリックし、開始アドレスを入力します。 4バイトを見て、それを003cf7c8 の開始アドレスに追加すると、003cf7cb になります。 既定では、すべてのメモリの書き込みが確認されますが、そのアドレスでの書き込みまたはコード実行だけを調べることもできます。

![[書き込み] ボタンがオンになっていることを示す [タイムラインメモリアクセス] ダイアログと003cf7c8 の開始値を追加する](images/windbgx-timeline-demo-lab-memory-access-dialog.png)

この時点で、タイムラインを逆方向に走査して、このメモリ位置がどの時点で見つかったかを確認できるようになりました。 タイムラインでこの位置をクリックすると、コピーされる文字列のローカル値が異なることがわかります。 文字列の長さが正しくないかのように、変換先の値が不完全である可能性があります。

![[メモリアクセスのタイムライン] ウィンドウと [ローカル] ウィンドウで、source と destination の値が異なるローカル値が表示される](images/windbgx-timeline-demo-lab-memory-access.png)

## <a name="breakpoint-timeline"></a>ブレークポイントのタイムライン

ブレークポイントの使用は、特定のイベントでコードの実行を一時停止するための一般的な方法です。 TTD を使用すると、トレースが記録された後にブレークポイントがヒットするまで、ブレークポイントを設定し、時間をさかのぼって戻すことができます。 問題が発生した後にプロセスの状態を確認する機能は、ブレークポイントの最適な場所を特定するために、TTD に固有の追加のデバッグワークフローを有効にします。

別のタイムラインデバッグ手法を調べるには、タイムラインで例外をクリックし、もう一度3つの手順を繰り返します。そのためには、[**ホーム**] リボンの [**ステップイン戻る**] コマンドを使用します。  

この非常に小さなサンプルでは、コードを簡単に調べることができますが、数百行のコードがあり、サブルーチンが多数ある場合は、ここで説明する手法を使用して、問題の特定に必要な時間を短縮できます。

前述のように、命令をポイントするのではなく、基本ポインター (esp) がメッセージテキストを指しています。

メモリアクセスにブレークポイントを設定するには、ba コマンドを使用します。 このメモリの領域が書き込まれるタイミングを確認するには、w 書き込みブレークポイントを設定します。

```dbgcmd
0:000> ba w4 003cf7c8
```

単純なメモリアクセスのブレークポイントを使用しますが、より複雑な条件ステートメントとしてブレークポイントを作成することもできます。 詳細については、「 [bp、bu、bm (ブレークポイントの設定)](bp--bu--bm--set-breakpoint-.md)」を参照してください。

[ホーム] メニューの [戻る]**を選択し**て、ブレークポイントにヒットするまで戻ります。

この時点で、プログラムスタックを調べて、アクティブなコードを確認できます。

![メモリアクセスタイムラインとスタックウィンドウを示すデバッガーのタイムライン](images/windbgx-timeline-demo-lab-stack.png)

Microsoft が提供する wscpy_s () 関数には、このようなコードのバグがあることはほとんどないため、スタックを詳しく見ていきます。 スタックには、そのことが案内されます。 main はあいさつを呼び出します。GetCppConGreeting。 非常に小さなコードサンプルでは、この時点でコードを開くだけで、エラーが非常に簡単に見つかる可能性があります。 しかし、より大規模で複雑なプログラムで使用できる手法を示すために、関数呼び出しのタイムラインを追加するように設定します。

## <a name="function-call-timeline"></a>関数呼び出しのタイムライン

[ **+ タイムラインの追加**] をクリックし、関数の検索文字列の `DisplayGreeting!GetCppConGreeting` を入力します。

[開始位置と終了位置] チェックボックスは、トレース内の関数呼び出しの開始と終了を示します。

Dx コマンドを使用すると、関数呼び出しオブジェクトを表示して、関数呼び出しの開始位置と終了位置に対応する TimeStart フィールドと Timestart フィールドに関連付けられていることを確認できます。

```dbgcmd
dx @$cursession.TTD.Calls("DisplayGreeting!GetCppConGreeting")[0x0]
    EventType        : 0x0
    ThreadId         : 0x6600
    UniqueThreadId   : 0x2
    TimeStart        : 6D:BD [Time Travel]
    SystemTimeStart  : Thursday, October 31, 2019 23:36:05
    TimeEnd          : 6D:742 [Time Travel]
    SystemTimeEnd    : Thursday, October 31, 2019 23:36:05
    Function         : DisplayGreeting!GetCppConGreeting
    FunctionAddress  : 0x615a0
    ReturnAddress    : 0x61746
    Parameters  
```

開始または終了、または [開始] と [終了] の両方の場所のチェックボックスをオンにする必要があります。

![メモリアクセスタイムラインとローカルウィンドウを示すデバッガーのタイムライン](images/windbgx-timeline-demo-lab-function-dialog.png)

コードは再帰的または再入可能ではありませんが、GetCppConGreeting メソッドが呼び出されたときに、タイムラインで簡単に見つけることができます。 GetCppConGreeting の呼び出しも、ブレークポイントと定義したメモリアクセスイベントと同時に発生します。 コードの領域を絞り込んで、アプリケーションクラッシュの根本原因を注意深く確認しているように見えます。

![メモリアクセスタイムラインとローカルウィンドウを示すデバッガーのタイムライン](images/windbgx-timeline-demo-lab-function.png)

## <a name="explore-code-execution-by-viewing-multiple-timelines"></a>複数のタイムラインを表示してコードの実行を調べる

コードサンプルは小さいですが、複数のタイムラインを使用する手法では、タイムトラベルトレースを視覚的に調査できます。 トレースファイルを調べて、"ブレークポイントがヒットする前にアクセスされたメモリ領域はどのようなものか" などの質問をすることができます。

![メモリアクセスタイムラインとローカルウィンドウを示すデバッガーのタイムライン](images/windbgx-timeline-demo-lab-locals.png)

追加の相関関係を確認し、予想されていないものを見つけることができるので、タイムラインツールは、コマンドラインコマンドを使用してタイムトラベルトレースと対話します。

### <a name="see-also"></a>参照

[WinDbg プレビューを使用したデバッグ](debugging-using-windbg-preview.md)

[タイムトラベルデバッグのチュートリアル](time-travel-debugging-walkthrough.md)

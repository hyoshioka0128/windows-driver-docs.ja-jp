---
title: プリンター ドライバー コンポーネントのデバッグ
description: プリンター ドライバー コンポーネントのデバッグ
ms.assetid: 550cc8fe-5520-4521-8c4e-9c8c80521357
keywords:
- デバッグドライバーの WDK プリンター
- プリンタードライバー WDK、デバッグ
- ユーザーモードでの WDK プリンターのデバッグ
- マクロ WDK プリンター
- グローバル変数 WDK デバッグ
ms.date: 06/04/2020
ms.localizationpriority: medium
ms.openlocfilehash: 336bb2e91a47ce512fa618d6e2d74726d7fc12ba
ms.sourcegitcommit: 0a0b75d93130b6c5854279607cd0aac099f65fd5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/04/2020
ms.locfileid: "84428315"
---
# <a name="debugging-printer-driver-components"></a>プリンター ドライバー コンポーネントのデバッグ

プリンタードライバーのレンダリングプラグインまたはユーザーインターフェイスプラグインを開発している場合は、これらのコンポーネントでデバッグメッセージを有効にすることができます。 「グローバルデバッグ変数」セクションで説明したように、グローバルデバッグ変数を使用して、デバッガーウィンドウに表示されるメッセージの詳細レベルを制御できます。

「デバッグメッセージマクロ」セクションで説明されているマクロを使用して、さまざまな条件下でデバッガーウィンドウにメッセージを送信できます。 また、このセクションの情報を使用して、これらの Dll のビルドがチェックされている場合に、Microsoft Universal Printer Driver (Unidrv) レンダラーまたは PostScript プリンタードライバー (Pscript) レンダラーでデバッグメッセージを有効にすることができます。

> [!NOTE]
> チェックを行ったビルドは、Windows 10 バージョン1803より前の古いバージョンの Windows で使用できました。
> Driver Verifier や GFlags などのツールを使用して、新しいバージョンの Windows でドライバーコードを確認します。

ユーザーモードドライバーのデバッグ手順と、一般的なデバッグのヒントを次の2つのセクションに示します。

## <a name="preparing-for-user-mode-debugging"></a>ユーザーモードデバッグの準備

プリンタドライバとそのコンポーネントのデバッグを開始するには、次のようにします。

1. 最新のデバッグツールをインストールします。 「 [Windows 用デバッグツールのダウンロード」を](https://docs.microsoft.com/windows-hardware/drivers/debugger/debugger-download-tools)参照してください。

1. [Windows シンボルパッケージ](https://docs.microsoft.com/windows-hardware/drivers/debugger/debugger-download-symbols)から正しいシンボルをインストールする

> [!NOTE]
> 最新バージョンのデバッガーを使用することが非常に重要です。

デバッグに関心のあるコンポーネントについてのみ、チェックを行ったビルドをインストールすることをお勧めします。 通常は、次の製品バイナリを対応するチェックされたビルドに置き換えます。

- Unidrv

- Unidrvui

- Unires .dll

また、Oemuni サンプルまたはデバッグ中のプリンタードライバーのチェックされたビルドもインストールする必要があります。 チェックを行うビルドシステム全体をインストールするのではなく、この方法を使用する利点は、システム全体の速度が低下しないことです。

## <a name="starting-a-user-mode-debugging-session"></a>ユーザーモードのデバッグセッションを開始しています

ユーザーモードのデバッグを開始するには、Windbg デバッガーの [**ファイル**] メニューの [**プロセスにアタッチ**] を選択します。 デバッガーをアタッチするプロセスは、デバッグしようとしているシナリオによって異なります。 プリンタードライバーの場合は、印刷アプリケーションまたはスプーラプロセス (Spoolsv.exe) のいずれかにデバッガーをアタッチする必要があります。 印刷アプリケーションでは、構成/ユーザーインターフェイスモジュールが読み込まれ、スプーラプロセスによってレンダリングモジュールが読み込まれることに注意してください。 ただし、"FILE:" 印刷には、スプールが行われず、その結果、レンダリングモジュールも印刷アプリケーションによって読み込まれるという違いがあります。 したがって、正しいプロセスに接続していることを確認する必要があります。

> [!NOTE]
> ユーザーモードのデバッグには、2つの異なるコンピューターは必要ありません。

次の手順を実行すると、Oemuni サンプルをデバッグできます。

1. "FILE:" ポートに Oemuni サンプルをインストールします。

1. [**スタート**] メニューをクリックし、[すべての**プログラム**]、[**アクセサリ**]、[**ワードパッド**] の順に選択して、ワードパッドアプリケーションを起動します。

1. [WinDbg**ファイル**] メニューの [**プロセスにアタッチ**] をクリックします。 使用可能なプロセスの一覧で、[ **WordPad**] を選択します。

1. ワードパッドから印刷ジョブを開始します。 これで、Oemuni サンプルをデバッグする準備ができました。

GiDebugLevel 変数をオンにすることで、詳細なデバッグを有効にすることができます。 既定値は3で、これは警告を示します。 1に設定すると、VERBOSE が示されます。 最後の値を Unidrv に設定するには、デバッガーで次のコマンドを入力します。

```cmd
> ed unidrv!giDebugLevel 1
```

Oemuni サンプルを実行している場合は、同じデバッグ変数も適用されるため、詳細なデバッグを有効にするには、次のコマンドを入力します。

```cmd
> ed oemuni!giDebugLevel 1
```

また、独自のデバッグステートメントを Oemuni サンプルに追加することもできます。

デバッグ値の設定の詳細については、WinDbg のドキュメントを参照してください。このドキュメントでは、使用可能なコマンドと、ユーザーモードのデバッグを設定するために必要な手順の概要を説明しています。 ドキュメントにアクセスするには、[WinDbg**ヘルプ**] メニューの [**コンテンツ**] を選択します。

## <a name="global-debug-variable"></a>グローバルデバッグ変数

GiDebugLevel グローバル変数は、Oemui および Oemui サンプルによって、デバッグ .h およびデバッグ .cpp ファイルで宣言されます。 GiDebugLevel の値は、次の方法で変更できます。

- デバッガーでの値の変更
- プラグインで値を再定義する

GiDebugLevel は、次のいずれかの値に設定できます。

```cpp
#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
```

## <a name="debug-message-macros"></a>デバッグメッセージマクロ

次のマクロは、デバッグの目的で使用されます。 そのうちのいくつかは、どのデバッグメッセージを出力するかを制御する giDebugLevel グローバル変数が特定の値に設定されている場合にのみ、アクションを実行します。 マクロは、無料のビルドでは空白まで拡張されます。 ここでは、その機能とそのパラメーターについて簡単に説明します。

**ASSERT**(*任意*)

- 指定されたブール式が**TRUE**かどう*かを検証*します。 そうでない場合は、マクロによって強制的にブレークポイントが実行されます。

**ASSERTMSG**(同一 *、* (*msg*))

- 指定されたブール式が**TRUE**かどう*かを検証*します。 そうでない場合、マクロは*msg*にメッセージを表示し、強制的にブレークポイントを強制します。

**ERR**((*msg*))

- 現在のデバッグレベルが DBG エラーの場合、メッセージを*msg*に表示し &lt; \_ ます。 メッセージ形式は次のとおりです。

    ```cpp
    ERR filename (linenumber): msg
    ```

**RIP**((*msg*))

- メッセージを*msg*に表示し、ブレークポイントを強制します。

**簡潔**((*msg*))

- 現在のデバッグレベルが DBG である場合は、メッセージを*msg*に表示し &lt; \_ ます。

**VERBOSE**((*msg*))

- 現在のデバッグレベルが DBG 詳細である場合、メッセージを*msg*に表示し &lt; \_ ます。

**警告**((*msg*))

- 現在のデバッグレベルが DBG 警告の場合、メッセージを*msg*に表示し &lt; \_ ます。 メッセージ形式は次のとおりです。

    ```cpp
    WRN filename (linenumber): msg
    ```

*Msg*引数を持つすべてのマクロには、この引数を囲むかっこの追加ペアが必要であることに注意してください。 この要件を示す2つの例を次に示します。

```cpp
ASSERTMSG(x > 0, ("x is less than 0\n"));
```

```cpp
WARNING( ("App passed NULL pointer, ignoring...\n") );
```

*Msg*引数を含むマクロは、その Debug ヘッダー内の oemui および oemui サンプルによって定義されます。
